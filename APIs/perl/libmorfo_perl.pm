# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.40
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package libmorfo_perl;
use base qw(Exporter);
use base qw(DynaLoader);
package libmorfo_perlc;
bootstrap libmorfo_perl;
package libmorfo_perl;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package libmorfo_perl;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package libmorfo_perl;


############# Class : libmorfo_perl::VectorWord ##############

package libmorfo_perl::VectorWord;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_VectorWord(@_);
    bless $self, $pkg if defined($self);
}

*size = *libmorfo_perlc::VectorWord_size;
*empty = *libmorfo_perlc::VectorWord_empty;
*clear = *libmorfo_perlc::VectorWord_clear;
*push = *libmorfo_perlc::VectorWord_push;
*pop = *libmorfo_perlc::VectorWord_pop;
*get = *libmorfo_perlc::VectorWord_get;
*set = *libmorfo_perlc::VectorWord_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_VectorWord($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::ListWord ##############

package libmorfo_perl::ListWord;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_ListWord(@_);
    bless $self, $pkg if defined($self);
}

*size = *libmorfo_perlc::ListWord_size;
*empty = *libmorfo_perlc::ListWord_empty;
*clear = *libmorfo_perlc::ListWord_clear;
*push = *libmorfo_perlc::ListWord_push;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_ListWord($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::ListAnalysis ##############

package libmorfo_perl::ListAnalysis;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_ListAnalysis(@_);
    bless $self, $pkg if defined($self);
}

*size = *libmorfo_perlc::ListAnalysis_size;
*empty = *libmorfo_perlc::ListAnalysis_empty;
*clear = *libmorfo_perlc::ListAnalysis_clear;
*push = *libmorfo_perlc::ListAnalysis_push;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_ListAnalysis($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::ListSentence ##############

package libmorfo_perl::ListSentence;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_ListSentence(@_);
    bless $self, $pkg if defined($self);
}

*size = *libmorfo_perlc::ListSentence_size;
*empty = *libmorfo_perlc::ListSentence_empty;
*clear = *libmorfo_perlc::ListSentence_clear;
*push = *libmorfo_perlc::ListSentence_push;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_ListSentence($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::ListParagraph ##############

package libmorfo_perl::ListParagraph;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_ListParagraph(@_);
    bless $self, $pkg if defined($self);
}

*size = *libmorfo_perlc::ListParagraph_size;
*empty = *libmorfo_perlc::ListParagraph_empty;
*clear = *libmorfo_perlc::ListParagraph_clear;
*push = *libmorfo_perlc::ListParagraph_push;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_ListParagraph($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::ListString ##############

package libmorfo_perl::ListString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_ListString(@_);
    bless $self, $pkg if defined($self);
}

*size = *libmorfo_perlc::ListString_size;
*empty = *libmorfo_perlc::ListString_empty;
*clear = *libmorfo_perlc::ListString_clear;
*push = *libmorfo_perlc::ListString_push;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_ListString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::ListInt ##############

package libmorfo_perl::ListInt;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_ListInt(@_);
    bless $self, $pkg if defined($self);
}

*size = *libmorfo_perlc::ListInt_size;
*empty = *libmorfo_perlc::ListInt_empty;
*clear = *libmorfo_perlc::ListInt_clear;
*push = *libmorfo_perlc::ListInt_push;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_ListInt($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::VectorListInt ##############

package libmorfo_perl::VectorListInt;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_VectorListInt(@_);
    bless $self, $pkg if defined($self);
}

*size = *libmorfo_perlc::VectorListInt_size;
*empty = *libmorfo_perlc::VectorListInt_empty;
*clear = *libmorfo_perlc::VectorListInt_clear;
*push = *libmorfo_perlc::VectorListInt_push;
*pop = *libmorfo_perlc::VectorListInt_pop;
*get = *libmorfo_perlc::VectorListInt_get;
*set = *libmorfo_perlc::VectorListInt_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_VectorListInt($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::VectorListString ##############

package libmorfo_perl::VectorListString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_VectorListString(@_);
    bless $self, $pkg if defined($self);
}

*size = *libmorfo_perlc::VectorListString_size;
*empty = *libmorfo_perlc::VectorListString_empty;
*clear = *libmorfo_perlc::VectorListString_clear;
*push = *libmorfo_perlc::VectorListString_push;
*pop = *libmorfo_perlc::VectorListString_pop;
*get = *libmorfo_perlc::VectorListString_get;
*set = *libmorfo_perlc::VectorListString_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_VectorListString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::TreeNode ##############

package libmorfo_perl::TreeNode;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
*swig_info_get = *libmorfo_perlc::TreeNode_info_get;
*swig_info_set = *libmorfo_perlc::TreeNode_info_set;
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_TreeNode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_TreeNode($self);
        delete $OWNER{$self};
    }
}

*num_children = *libmorfo_perlc::TreeNode_num_children;
*nth_child = *libmorfo_perlc::TreeNode_nth_child;
*nth_child_ref = *libmorfo_perlc::TreeNode_nth_child_ref;
*get_info = *libmorfo_perlc::TreeNode_get_info;
*append_child = *libmorfo_perlc::TreeNode_append_child;
*hang_child = *libmorfo_perlc::TreeNode_hang_child;
*clear = *libmorfo_perlc::TreeNode_clear;
*empty = *libmorfo_perlc::TreeNode_empty;
*sibling_begin = *libmorfo_perlc::TreeNode_sibling_begin;
*sibling_end = *libmorfo_perlc::TreeNode_sibling_end;
*begin = *libmorfo_perlc::TreeNode_begin;
*end = *libmorfo_perlc::TreeNode_end;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::TreeDepnode ##############

package libmorfo_perl::TreeDepnode;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
*swig_info_get = *libmorfo_perlc::TreeDepnode_info_get;
*swig_info_set = *libmorfo_perlc::TreeDepnode_info_set;
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_TreeDepnode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_TreeDepnode($self);
        delete $OWNER{$self};
    }
}

*num_children = *libmorfo_perlc::TreeDepnode_num_children;
*nth_child = *libmorfo_perlc::TreeDepnode_nth_child;
*nth_child_ref = *libmorfo_perlc::TreeDepnode_nth_child_ref;
*get_info = *libmorfo_perlc::TreeDepnode_get_info;
*append_child = *libmorfo_perlc::TreeDepnode_append_child;
*hang_child = *libmorfo_perlc::TreeDepnode_hang_child;
*clear = *libmorfo_perlc::TreeDepnode_clear;
*empty = *libmorfo_perlc::TreeDepnode_empty;
*sibling_begin = *libmorfo_perlc::TreeDepnode_sibling_begin;
*sibling_end = *libmorfo_perlc::TreeDepnode_sibling_end;
*begin = *libmorfo_perlc::TreeDepnode_begin;
*end = *libmorfo_perlc::TreeDepnode_end;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::analysis ##############

package libmorfo_perl::analysis;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
*swig_user_get = *libmorfo_perlc::analysis_user_get;
*swig_user_set = *libmorfo_perlc::analysis_user_set;
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_analysis(@_);
    bless $self, $pkg if defined($self);
}

*operator_assignment = *libmorfo_perlc::analysis_operator_assignment;
*set_lemma = *libmorfo_perlc::analysis_set_lemma;
*set_parole = *libmorfo_perlc::analysis_set_parole;
*set_prob = *libmorfo_perlc::analysis_set_prob;
*set_retokenizable = *libmorfo_perlc::analysis_set_retokenizable;
*has_prob = *libmorfo_perlc::analysis_has_prob;
*get_lemma = *libmorfo_perlc::analysis_get_lemma;
*get_parole = *libmorfo_perlc::analysis_get_parole;
*get_short_parole = *libmorfo_perlc::analysis_get_short_parole;
*get_prob = *libmorfo_perlc::analysis_get_prob;
*is_retokenizable = *libmorfo_perlc::analysis_is_retokenizable;
*get_retokenizable = *libmorfo_perlc::analysis_get_retokenizable;
*get_senses_string = *libmorfo_perlc::analysis_get_senses_string;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_analysis($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::word ##############

package libmorfo_perl::word;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl::ListAnalysis libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
*swig_user_get = *libmorfo_perlc::word_user_get;
*swig_user_set = *libmorfo_perlc::word_user_set;
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_word(@_);
    bless $self, $pkg if defined($self);
}

*operator_assignment = *libmorfo_perlc::word_operator_assignment;
*get_n_selected = *libmorfo_perlc::word_get_n_selected;
*get_n_unselected = *libmorfo_perlc::word_get_n_unselected;
*is_multiword = *libmorfo_perlc::word_is_multiword;
*get_n_words_mw = *libmorfo_perlc::word_get_n_words_mw;
*get_words_mw = *libmorfo_perlc::word_get_words_mw;
*get_form = *libmorfo_perlc::word_get_form;
*selected_begin = *libmorfo_perlc::word_selected_begin;
*selected_end = *libmorfo_perlc::word_selected_end;
*unselected_begin = *libmorfo_perlc::word_unselected_begin;
*unselected_end = *libmorfo_perlc::word_unselected_end;
*get_lemma = *libmorfo_perlc::word_get_lemma;
*get_parole = *libmorfo_perlc::word_get_parole;
*get_short_parole = *libmorfo_perlc::word_get_short_parole;
*get_senses_string = *libmorfo_perlc::word_get_senses_string;
*get_span_start = *libmorfo_perlc::word_get_span_start;
*get_span_finish = *libmorfo_perlc::word_get_span_finish;
*found_in_dict = *libmorfo_perlc::word_found_in_dict;
*set_found_in_dict = *libmorfo_perlc::word_set_found_in_dict;
*has_retokenizable = *libmorfo_perlc::word_has_retokenizable;
*add_analysis = *libmorfo_perlc::word_add_analysis;
*set_analysis = *libmorfo_perlc::word_set_analysis;
*set_form = *libmorfo_perlc::word_set_form;
*set_span = *libmorfo_perlc::word_set_span;
*find_tag_match = *libmorfo_perlc::word_find_tag_match;
*get_n_analysis = *libmorfo_perlc::word_get_n_analysis;
*copy_analysis = *libmorfo_perlc::word_copy_analysis;
*unselect_all_analysis = *libmorfo_perlc::word_unselect_all_analysis;
*select_all_analysis = *libmorfo_perlc::word_select_all_analysis;
*select_analysis = *libmorfo_perlc::word_select_analysis;
*unselect_analysis = *libmorfo_perlc::word_unselect_analysis;
*get_analysis = *libmorfo_perlc::word_get_analysis;
*analysis_begin = *libmorfo_perlc::word_analysis_begin;
*analysis_end = *libmorfo_perlc::word_analysis_end;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_word($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::node ##############

package libmorfo_perl::node;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_node(@_);
    bless $self, $pkg if defined($self);
}

*get_label = *libmorfo_perlc::node_get_label;
*get_word = *libmorfo_perlc::node_get_word;
*set_word = *libmorfo_perlc::node_set_word;
*set_label = *libmorfo_perlc::node_set_label;
*is_head = *libmorfo_perlc::node_is_head;
*set_head = *libmorfo_perlc::node_set_head;
*is_chunk = *libmorfo_perlc::node_is_chunk;
*set_chunk = *libmorfo_perlc::node_set_chunk;
*get_chunk_ord = *libmorfo_perlc::node_get_chunk_ord;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_node($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::parse_tree ##############

package libmorfo_perl::parse_tree;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl::TreeNode libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_parse_tree(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_parse_tree($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::depnode ##############

package libmorfo_perl::depnode;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl::node libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_depnode(@_);
    bless $self, $pkg if defined($self);
}

*set_link = *libmorfo_perlc::depnode_set_link;
*get_link = *libmorfo_perlc::depnode_get_link;
*get_link_ref = *libmorfo_perlc::depnode_get_link_ref;
*set_label = *libmorfo_perlc::depnode_set_label;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_depnode($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::dep_tree ##############

package libmorfo_perl::dep_tree;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl::TreeDepnode libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_dep_tree(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_dep_tree($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::sentence ##############

package libmorfo_perl::sentence;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl::ListWord libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_sentence(@_);
    bless $self, $pkg if defined($self);
}

*set_parse_tree = *libmorfo_perlc::sentence_set_parse_tree;
*get_parse_tree = *libmorfo_perlc::sentence_get_parse_tree;
*is_parsed = *libmorfo_perlc::sentence_is_parsed;
*get_dep_tree = *libmorfo_perlc::sentence_get_dep_tree;
*set_dep_tree = *libmorfo_perlc::sentence_set_dep_tree;
*is_dep_parsed = *libmorfo_perlc::sentence_is_dep_parsed;
*get_words = *libmorfo_perlc::sentence_get_words;
*words_begin = *libmorfo_perlc::sentence_words_begin;
*words_end = *libmorfo_perlc::sentence_words_end;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_sentence($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::paragraph ##############

package libmorfo_perl::paragraph;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl::ListSentence libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_paragraph(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_paragraph($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::document ##############

package libmorfo_perl::document;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl::ListParagraph libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_document(@_);
    bless $self, $pkg if defined($self);
}

*add_positive = *libmorfo_perlc::document_add_positive;
*get_coref_group = *libmorfo_perlc::document_get_coref_group;
*get_coref_nodes = *libmorfo_perlc::document_get_coref_nodes;
*is_coref = *libmorfo_perlc::document_is_coref;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_document($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::fex ##############

package libmorfo_perl::fex;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_fex(@_);
    bless $self, $pkg if defined($self);
}

*encode_name = *libmorfo_perlc::fex_encode_name;
*encode_int = *libmorfo_perlc::fex_encode_int;
*clear_lexicon = *libmorfo_perlc::fex_clear_lexicon;
*add_lexicon = *libmorfo_perlc::fex_add_lexicon;
*save_lexicon = *libmorfo_perlc::fex_save_lexicon;
*load_lexicon = *libmorfo_perlc::fex_load_lexicon;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_fex($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::traces ##############

package libmorfo_perl::traces;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
*TraceLevel = *libmorfo_perlc::traces_TraceLevel;
*TraceModule = *libmorfo_perlc::traces_TraceModule;
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_traces(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_traces($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::tokenizer ##############

package libmorfo_perl::tokenizer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_tokenizer(@_);
    bless $self, $pkg if defined($self);
}

*tokenize = *libmorfo_perlc::tokenizer_tokenize;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_tokenizer($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::splitter ##############

package libmorfo_perl::splitter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_splitter(@_);
    bless $self, $pkg if defined($self);
}

*split = *libmorfo_perlc::splitter_split;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_splitter($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::maco_options ##############

package libmorfo_perl::maco_options;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
*swig_Lang_get = *libmorfo_perlc::maco_options_Lang_get;
*swig_Lang_set = *libmorfo_perlc::maco_options_Lang_set;
*swig_AffixAnalysis_get = *libmorfo_perlc::maco_options_AffixAnalysis_get;
*swig_AffixAnalysis_set = *libmorfo_perlc::maco_options_AffixAnalysis_set;
*swig_MultiwordsDetection_get = *libmorfo_perlc::maco_options_MultiwordsDetection_get;
*swig_MultiwordsDetection_set = *libmorfo_perlc::maco_options_MultiwordsDetection_set;
*swig_NumbersDetection_get = *libmorfo_perlc::maco_options_NumbersDetection_get;
*swig_NumbersDetection_set = *libmorfo_perlc::maco_options_NumbersDetection_set;
*swig_PunctuationDetection_get = *libmorfo_perlc::maco_options_PunctuationDetection_get;
*swig_PunctuationDetection_set = *libmorfo_perlc::maco_options_PunctuationDetection_set;
*swig_DatesDetection_get = *libmorfo_perlc::maco_options_DatesDetection_get;
*swig_DatesDetection_set = *libmorfo_perlc::maco_options_DatesDetection_set;
*swig_QuantitiesDetection_get = *libmorfo_perlc::maco_options_QuantitiesDetection_get;
*swig_QuantitiesDetection_set = *libmorfo_perlc::maco_options_QuantitiesDetection_set;
*swig_DictionarySearch_get = *libmorfo_perlc::maco_options_DictionarySearch_get;
*swig_DictionarySearch_set = *libmorfo_perlc::maco_options_DictionarySearch_set;
*swig_ProbabilityAssignment_get = *libmorfo_perlc::maco_options_ProbabilityAssignment_get;
*swig_ProbabilityAssignment_set = *libmorfo_perlc::maco_options_ProbabilityAssignment_set;
*swig_NERecognition_get = *libmorfo_perlc::maco_options_NERecognition_get;
*swig_NERecognition_set = *libmorfo_perlc::maco_options_NERecognition_set;
*swig_Decimal_get = *libmorfo_perlc::maco_options_Decimal_get;
*swig_Decimal_set = *libmorfo_perlc::maco_options_Decimal_set;
*swig_Thousand_get = *libmorfo_perlc::maco_options_Thousand_get;
*swig_Thousand_set = *libmorfo_perlc::maco_options_Thousand_set;
*swig_LocutionsFile_get = *libmorfo_perlc::maco_options_LocutionsFile_get;
*swig_LocutionsFile_set = *libmorfo_perlc::maco_options_LocutionsFile_set;
*swig_QuantitiesFile_get = *libmorfo_perlc::maco_options_QuantitiesFile_get;
*swig_QuantitiesFile_set = *libmorfo_perlc::maco_options_QuantitiesFile_set;
*swig_AffixFile_get = *libmorfo_perlc::maco_options_AffixFile_get;
*swig_AffixFile_set = *libmorfo_perlc::maco_options_AffixFile_set;
*swig_ProbabilityFile_get = *libmorfo_perlc::maco_options_ProbabilityFile_get;
*swig_ProbabilityFile_set = *libmorfo_perlc::maco_options_ProbabilityFile_set;
*swig_DictionaryFile_get = *libmorfo_perlc::maco_options_DictionaryFile_get;
*swig_DictionaryFile_set = *libmorfo_perlc::maco_options_DictionaryFile_set;
*swig_NPdataFile_get = *libmorfo_perlc::maco_options_NPdataFile_get;
*swig_NPdataFile_set = *libmorfo_perlc::maco_options_NPdataFile_set;
*swig_PunctuationFile_get = *libmorfo_perlc::maco_options_PunctuationFile_get;
*swig_PunctuationFile_set = *libmorfo_perlc::maco_options_PunctuationFile_set;
*swig_ProbabilityThreshold_get = *libmorfo_perlc::maco_options_ProbabilityThreshold_get;
*swig_ProbabilityThreshold_set = *libmorfo_perlc::maco_options_ProbabilityThreshold_set;
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_maco_options(@_);
    bless $self, $pkg if defined($self);
}

*set_active_modules = *libmorfo_perlc::maco_options_set_active_modules;
*set_nummerical_points = *libmorfo_perlc::maco_options_set_nummerical_points;
*set_data_files = *libmorfo_perlc::maco_options_set_data_files;
*set_threshold = *libmorfo_perlc::maco_options_set_threshold;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_maco_options($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::maco ##############

package libmorfo_perl::maco;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_maco(@_);
    bless $self, $pkg if defined($self);
}

*analyze = *libmorfo_perlc::maco_analyze;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_maco($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::hmm_tagger ##############

package libmorfo_perl::hmm_tagger;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_hmm_tagger(@_);
    bless $self, $pkg if defined($self);
}

*analyze = *libmorfo_perlc::hmm_tagger_analyze;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_hmm_tagger($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::relax_tagger ##############

package libmorfo_perl::relax_tagger;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_relax_tagger(@_);
    bless $self, $pkg if defined($self);
}

*analyze = *libmorfo_perlc::relax_tagger_analyze;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_relax_tagger($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::nec ##############

package libmorfo_perl::nec;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_nec(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_nec($self);
        delete $OWNER{$self};
    }
}

*analyze = *libmorfo_perlc::nec_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::chart_parser ##############

package libmorfo_perl::chart_parser;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_chart_parser(@_);
    bless $self, $pkg if defined($self);
}

*get_start_symbol = *libmorfo_perlc::chart_parser_get_start_symbol;
*analyze = *libmorfo_perlc::chart_parser_analyze;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_chart_parser($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::dependency_parser ##############

package libmorfo_perl::dependency_parser;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_dependency_parser($self);
        delete $OWNER{$self};
    }
}

*analyze = *libmorfo_perlc::dependency_parser_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::dep_txala ##############

package libmorfo_perl::dep_txala;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl::dependency_parser libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_dep_txala(@_);
    bless $self, $pkg if defined($self);
}

*analyze = *libmorfo_perlc::dep_txala_analyze;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_dep_txala($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::senses ##############

package libmorfo_perl::senses;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_senses(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_senses($self);
        delete $OWNER{$self};
    }
}

*analyze = *libmorfo_perlc::senses_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::disambiguator ##############

package libmorfo_perl::disambiguator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_disambiguator(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_disambiguator($self);
        delete $OWNER{$self};
    }
}

*analyze = *libmorfo_perlc::disambiguator_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::sense_info ##############

package libmorfo_perl::sense_info;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
*swig_sense_get = *libmorfo_perlc::sense_info_sense_get;
*swig_sense_set = *libmorfo_perlc::sense_info_sense_set;
*swig_pos_get = *libmorfo_perlc::sense_info_pos_get;
*swig_pos_set = *libmorfo_perlc::sense_info_pos_set;
*swig_parents_get = *libmorfo_perlc::sense_info_parents_get;
*swig_parents_set = *libmorfo_perlc::sense_info_parents_set;
*swig_semfile_get = *libmorfo_perlc::sense_info_semfile_get;
*swig_semfile_set = *libmorfo_perlc::sense_info_semfile_set;
*swig_words_get = *libmorfo_perlc::sense_info_words_get;
*swig_words_set = *libmorfo_perlc::sense_info_words_set;
*swig_tonto_get = *libmorfo_perlc::sense_info_tonto_get;
*swig_tonto_set = *libmorfo_perlc::sense_info_tonto_set;
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_sense_info(@_);
    bless $self, $pkg if defined($self);
}

*get_parents_string = *libmorfo_perlc::sense_info_get_parents_string;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_sense_info($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libmorfo_perl::semanticDB ##############

package libmorfo_perl::semanticDB;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libmorfo_perl );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libmorfo_perlc::new_semanticDB(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libmorfo_perlc::delete_semanticDB($self);
        delete $OWNER{$self};
    }
}

*get_sense_words = *libmorfo_perlc::semanticDB_get_sense_words;
*get_word_senses = *libmorfo_perlc::semanticDB_get_word_senses;
*get_sense_info = *libmorfo_perlc::semanticDB_get_sense_info;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package libmorfo_perl;

*traces_TraceLevel = *libmorfo_perlc::traces_TraceLevel;
*traces_TraceModule = *libmorfo_perlc::traces_TraceModule;
1;
